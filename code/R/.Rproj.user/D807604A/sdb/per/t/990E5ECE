{
    "contents" : "#########################################################################\n# MCMC \n#\n# TODO: Add in model description here\n#########################################################################\n\nmcmc <- function(y, s, x, s.pred=NULL, x.pred=NULL, \n                 thresh=0, thresh.quant=T, nknots=1,          \n                 iters=5000, burn=1000, update=100, thin=1, scale=T,\n                 iterplot=F, plotname=NULL,\n                 # initial values\n                 beta.init=NULL, sigma.init=1,\n                 rho.init=0.5, nu.init=0.5, alpha.init=0.5,\n                 delta.init=0,\n                 # priors\n                 beta.m=0, beta.s=10, sigma.a=1, sigma.b=1,\n                 logrho.m=-2, logrho.s=1,\n                 lognu.m=-1.2, lognu.s=1,\n                 alpha.m=0, alpha.s=1,\n                 # debugging settings\n                 debug=F, knots.init, z.init, \n                 fixknots=F, fixz=F, fixbeta=F, fixsigma=F,\n                 fixrho=F, fixnu=F, fixalpha=F,\n                 fixdelta=F){\n    \n  start.time <- proc.time()\n   \n  ##############################################\n  # Initial setup\n  ##############################################\n  \n  ##############################################\n  # Initial setup\n  ##############################################\n  ns <- nrow(y)  # number of sites\n  nt <- ncol(y)  # number of days\n    \n  # rescale the x and y coordinates to be in [0, 1] x [0, 1]\n  predictions <- !is.null(s.pred) & !is.null(x.pred)\n  np <- 0\n  y.pred <- NULL\n  if (predictions) {\n    np <- nrow(s.pred)\n    if (scale) {\n      s.unscale      <- s\n      s.pred.unscale <- s.pred\n      s.scale        <- ScaleLocs(rbind(s.unscale, s.pred.unscale))\n      s              <- s.scale[1:ns, ]\n      s.pred         <- s.scale[(ns + 1):(ns + np), ]\n    }\n    d12 <- rdist(s.pred, s)\n    d11 <- rdist(s.pred, s.pred)\n    diag(d11) <- 0\n    y.pred <- array(0, c(np, nt, iters))\n  } else {\n    if (scale) {\n      s.unscale <- s\n      s <- ScaleLocs(s = s)\n    }\n  }    \n    \n  d       <- rdist(s)  # distance between sites\n  diag(d) <- 0\n    \n  p <- dim(x)[3]  # number of covariates\n  if (is.null(nknots)) { nknots = 1 }  # even if not using partition, still need\n                                       # nknots\n    \n  # store the loc/day for observed values below thresh.\n  if (thresh.quant) {               # threshold based on sample quantiles\n    thresh.data <- quantile(y, thresh)\n  } else {                        # threshold based on fixed value\n    thresh.data <- thresh\n  }\n  thresh.mtx   <- matrix(thresh.data, ns, nt)  # need thresh in matrix form\n  thresh.obs   <- !is.na(y) & (y <= thresh.mtx)\n    \n  # if there are some missing days, store the indices before\n  # the first imputation. then set initial value as the average ozone\n  # for all sites on the day.\n  missing.obs <- is.na(y)\n  for (t in 1:nt) {\n    missing.sites       <- missing.obs[, t]\n    y[missing.sites, t] <- mean(y[, t], na.rm=T)\n  }\n    \n  # initialize partition\n  knots <- vector(mode=\"list\", length=nt)\n  knots.min.1 <- range( s[, 1] )[1]\n  knots.max.1 <- range( s[, 1] )[2]\n  knots.min.2 <- range( s[, 2] )[1]\n  knots.max.2 <- range( s[, 2] )[2]\n  for (t in 1:nt) {\n    knots[[t]]     <- matrix(NA, nknots, 2)\n    knots[[t]][, 1] <- runif(n=nknots, min=knots.min.1, max=knots.max.1)\n    knots[[t]][, 2] <- runif(n=nknots, min=knots.min.2, max=knots.max.2)\n  }\n    \n  if(fixknots){knots <- knots.init}  # debug\n       \n  partition <- Membership(s=s, knots=knots)\n  \n  # initialize random effects\n  z.knots <- matrix(1, nrow=nknots, ncol=nt)\n  z.sites <- matrix(NA, nrow=ns, ncol=nt)\n  if (fixz) {z.knots <- z.init}\n  for (t in 1:nt) {\n  \tz.sites[, t] <- ZBySites(z.knots[, t], partition[, t])\n  }\n    \n  # initialize parameters\n  if (is.null(beta.init)) {\n    beta <- rep(0, p)\n    beta[1] <- mean(y)  # set initial intercept\n  } else {\n  \tbeta <- beta.init\n  }\n  if(fixbeta){beta <- beta.init}  #debug\n   \n  x.beta <- matrix(NA, ns, nt)\n  for (t in 1:nt) {\n  \tx.beta[, t] <- x[, t, ] %*% beta\n  }\n  \n  # initialize spatial covariance\n  rho <- rho.init\n  logrho <- log(rho)\n  nu  <- nu.init\n  lognu <- log(nu)\n  alpha <- alpha.init\n  \n  if (length(sigma.init) == 1) {\n    sigma <- rep(sigma.init, nt)\n  } else {\n    sigma <- sigma.init\n  }\n  \n  cor.mtx <- SpatCor(d=d, alpha=alpha, rho=rho, nu=nu)\n  sig     <- cor.mtx$sig\n  prec    <- cor.mtx$prec\n  log.det <- cor.mtx$log.det\n  \n  if (delta.init < -1 | delta.init > 1) {\n    stop(\"delta.init must be between -1 and 1.\")\n  } else {\n    delta <- delta.init\n  }\n  \n  # MH tuning params\n  acc.w <- att.w <- mh.w <- rep(0.1, nt)  # knot locations\n  acc.delta <- att.delta <- mh.delta <- 0.1  \n  acc.rho   <- att.rho   <- mh.rho   <- 1\n  acc.nu    <- att.nu    <- mh.nu    <- 1\n  acc.alpha <- att.alpha <- mh.alpha <- 1\n  \n  # storage\n  if (debug) { print(\"storage\") }\n  keepers.z <- array(NA, dim=c(iters, nknots, nt))\n  keepers.beta <- matrix(NA, nrow=iters, ncol=p)\n  keepers.sigma <- keepers.ll <- matrix(NA, nrow=iters, ncol=nt)\n  keepers.delta <- keepers.rho <- keepers.nu <- keepers.alpha <- rep(NA, iters)\n  \n  # initial values\n  mu <- x.beta + delta * z.sites\n  cur.ll <- LLike(y=y, x.beta=x.beta, sigma=sigma, delta=delta, prec=prec, \n                  log.det=log.det, z.sites=z.sites, log=T)\n  \n  for (iter in 1:iters) { for (ttt in 1:thin) {\n    \n    # impute data below threshold\n    if (debug) { print(\"impute\") }\n    if (thresh != 0) {\n      mu <- x.beta + delta * z.sites\n      thresh.mtx.fudge <- 0.99999 * thresh.mtx.k  # numerical stability\n      y.imputed <- matrix(y, ns, nt)\n      \n      for (i in 1:ns) {\n        n.thresh.miss <- sum(thresh.days[i, ]) + sum(missing.days[i, ])\n        if (n.thresh.miss > 0){\n          s.22     <- sig[-i, -i]\n          s.22.inv <- chol2inv(chol(s.22))\n          s.12     <- matrix(sig[i, -i], 1, (ns - 1))\n          s.11     <- sig[i, i]\n          for (t in 1:nt) {\n          \te.y <- (mu[i, t]) + s.12 %*% s.22.inv %*% (y[-i, t] - mu[-i, t])\n            s.y <- sqrt((s.11 - s.12 %*% s.22.inv %*% t(s.12)) / sigma[t])\n            \n            y.impute.t <- rTNorm(mn=e.y, sd=s.y, lower=-Inf, upper=thresh.mtx.k[i, ])\n            \n            # if any z come back as -Inf it's because P(Y < T) = 0                    \n            if (y.impute.t == -Inf) {\n              y.impute.t <- thresh.mtx.fudge\n            }\n              \n            y.missing.t <- rnorm(n=1, mean=e.y, sd=s.y)\n            \n            if (thresh.days[i, t]) {\n              y.imputed[i, t] <- y.impute.t\n            }\n            \n            if (missing.days[i, t]) {\n              y.imputed[i, t] <- y.missing.t\n            }\n          }  # end nt\n        }  # fi n.thresh.miss > 0\n        \n      }  # end ns\n      \n      y <- y.imputed\n    }  # fi thresh != 0\n    \n    # update random effects\n    if (debug) {print(\"random z\")}\n    if (!fixz) {  # debug\n      for (t in 1:nt) {\n      \tvvv  <- sigma[t] * (1 - delta^2)\n        if (nknots > 1) {\n          for (k in 1:nknots) {\n            these   <- which(partition[, t] == k)\n            n.these <- length(these)\n            r1      <- y[these, t] - x.beta[these, t]\n            r2      <- y[-these, t] - x.beta[-these, t] - delta * z.sites[-these, t]\n            \n            prec.11 <- prec[these, these] / vvv\n            prec.21 <- prec[-these, these] / vvv\n            \n            mu.z    <- delta * sum(t(r1) %*% prec.11 + t(r2) %*% prec.21)\n            prec.z  <- delta^2 * sum(prec.11) + 1 / sigma[t]\n            var.z   <- 1 / prec.z\n        \n            z.new             <- rTNorm(mn=(var.z * mu.z), sd=sqrt(var.z), lower=0, upper=Inf) \n            z.knots[k, t]     <- z.new\n            z.sites[these, t] <- z.new\n          }  # end nknots\n        } else if (nknots == 1) {\n          r      <- y[, t] - x.beta[, t]\n          ppp    <- prec / vvv\n          mu.z   <- delta * sum(ppp %*% r)\n          prec.z <- delta^2 * sum(ppp) + 1 / sigma[t]\n          var.z  <- 1 / prec.z\n          \n          z.new        <- rTNorm(mn=(var.z * mu.z), sd=sqrt(var.z), lower=0, upper=Inf)\n          z.knots[, t] <- z.new\n          z.sites[, t] <- z.new\n        }  # fi nknots\n      }  # end nt\n      \n    }  # fi !fixz\n    \n    # update means\n    mu <- x.beta + delta * z.sites\n    \n    # update partitions\n    if (debug) { print(\"knots\") }\n    if (!fixknots) {  # debug\n      if (nknots > 1) {\n        for (t in 1:nt) {\n          can.knots <- knots\n          att.w[t] <- att.w[t] + 1\n          ss.t <- t(y[, t] - mu[, t]) %*% prec %*% (y[, t] - mu[, t])\n          cur.ll <- -0.5 * ss.t / (sigma[t] * (1 - delta^2))\n          \n          for (k in 1:nknots) {\n        \tcan.knots[[t]][k, ] <- rnorm(2, knots[[t]][k, ], mh.w[t])\n          }\n        \n          can.partition <- Membership(s=s, knots=can.knots)\n          can.z.sites <- ZBySites(z=z.knots, partition=can.partition)\n          can.mu.t <- x.beta[, t] + delta * can.z.sites\n          \n          can.ss <- t(y[, t] - can.mu.t) %*% prec %*% (y[, t] - can.mu.t)\n          can.ll <- -0.5 * can.ss / (sigma[t] * (1 - delta^2))\n          \n          rej <- sum(can.ll - cur.ll)  # prior is uniform and candidate is symmetric\n          \n          if (!is.na(rej)) {if (-rej < rexp(1, 1)) {\n            knots[[t]]     <- can.knots[[t]]\n            partition[, t] <- can.partition\n            z.sites[, t]   <- can.z.sites\n            mu[, t]        <- can.mu.t\n            acc.w[t]       <- acc.w[t] + 1\n            cur.ll         <- can.ll\n          }}\n          \n        } # end nt\n        \n      }  # fi nknots > 1\n    }  # fi !fixknots\n    \n    # update beta\n    if (debug) { print(\"beta\") }\n    if (!fixbeta) {  # debug\n      vvv <- diag(p) * 0.0001\n      mmm <- 0\n      \n      for (t in 1:nt) {\n        x.t <- x[, t, ]\n        ttt <- t(x.t) %*% prec / (sigma[t] * (1 - delta^2))\n        vvv <- vvv + ttt %*% x.t\n        mmm <- mmm + ttt %*% (y[, t] - delta * z.sites[, t])\n      }\n      \n      vvv <- solve(vvv)\n      beta <- vvv %*% mmm + t(chol(vvv)) %*% rnorm(p)\n      \n      for (t in 1:nt) {\n  \t    x.beta[, t] <- x[, t, ] %*% beta\n      }\n    }  #fi !fixbeta\n    \n    mu  <- x.beta + delta * z.sites\n    res <- y - mu\n    \n    # update delta\n    if (debug) { print(\"delta\") }\n    if (!fixdelta) {\n      att.delta <- att.delta + 1\n      \n      cur.rss <- SumSquares(res, prec) / (sigma * (1 - delta^2))\n      can.delta <- rnorm(1, delta, mh.delta)\n\n      if (can.delta > -1 & can.delta < 1) {\n      can.mu  <- x.beta + can.delta * z.sites\n\t    can.res <- y - can.mu\n\t    can.rss <- SumSquares(can.res, prec) / (sigma * (1 - can.delta^2))\n\n\t    rej <- -0.5 * sum(can.rss - cur.rss) - \n\t           0.5 * nt * ns * (log(1 - can.delta^2) - log(1 - delta^2))\n\t           \n\t    if (!is.na(rej)) { if (-rej < rexp(1, 1)) {\n\t      delta     <- can.delta\n\t      acc.delta <- acc.delta + 1\n\t    }}\n\t  }  # fi can.delta\n      \n    }  # fi !fixdelta\n    \n    #### Spatial correlation\n    \n#     mu  <- x.beta + delta * z.sites\n#     res <- y - mu\n    \n    # update sigma (sill)\n    if (debug) { print(\"sigma\") }\n    if (!fixsigma) {\n      alpha.star <- sigma.a + 0.5 * nknots + 0.5 * ns\n      beta.star  <- sigma.b + 0.5 * colSums(z.knots^2) + 0.5 * rss / (1 - delta^2)\n      sigma      <- 1 / rgamma(nt, alpha.star, beta.star)\n    }  # fi !fixsigma\n     \n    # rho and nu\n    if (debug) { print(\"rho and nu\") }\n    if (!fixrho | !fixnu) {\n      \n      cur.rss <- SumSquares(res, prec) / (sigma * (1 - delta^2))\n      \n      if (!fixrho) {\n      \tatt.rho    <- att.rho + 1\n        logrho     <- log(rho)\n        can.logrho <- rnorm(1, logrho, mh.rho)\n      } else {\n        can.logrho <- log(rho)\n      }\n      can.rho <- exp(can.logrho)\n      \n      if (!fixnu) {\n      \tatt.nu    <- att.nu + 1\n        lognu     <- log(nu)\n        can.lognu <- rnorm(1, lognu, mh.nu)\n      } else {\n        can.lognu <- log(nu)\n      }\n      can.nu <- exp(can.lognu)\n      \n      if (can.nu <= 10) {  # for numerical stability\n        can.cor.mtx <- SpatCor(d=d, alpha=alpha, rho=can.rho, nu=can.nu)\n        can.sig     <- can.cor.mtx$sig\n        can.prec    <- can.cor.mtx$prec\n        can.log.det <- can.cor.mtx$log.det\n        \n        can.rss     <- SumSquares(res, can.prec) / (sigma * (1 - delta^2))    \n                      \n        rej <- -0.5 * sum(can.rss - cur.rss) + \n               0.5 * nt * (can.log.det - log.det) + \n               dnorm(can.logrho, logrho.m, logrho.s, log=T) - \n               dnorm(logrho, logrho.m, logrho.s, log=T) +\n               dnorm(can.lognu, lognu.m, lognu.s, log=T) -\n               dnorm(lognu, lognu.m, lognu.s, log=T)\n        \n        if (!is.na(rej)) { if (-rej < rexp(1, 1)) {\n          rho     <- can.rho\n          nu      <- can.nu\n          cor.mtx <- can.cor.mtx\n          sig     <- can.sig\n          prec    <- can.prec\n          log.det <- can.log.det\n          if (!fixrho) { acc.rho <- acc.rho + 1 }\n          if (!fixnu) { acc.nu <- acc.nu + 1 }\n        }} \n      } # fi can.nu <= 10\n    } # fi !fixrho | !fixnu\n    \n    # alpha\n    if (debug) { print(\"alpha\") }\n    if (!fixalpha) {\n      cur.rss <- SumSquares(res, prec) / (sigma * (1 - delta^2))\n                      \n      att.alpha      <- att.alpha + 1\n      norm.alpha     <- qnorm(alpha)\n      can.norm.alpha <- rnorm(1, norm.alpha, mh.alpha)\n      can.alpha      <- pnorm(can.norm.alpha)\n      \n      can.cor.mtx <- SpatCor(d=d, alpha=can.alpha, rho=rho, nu=nu)\n      can.sig     <- can.cor.mtx$sig\n      can.prec    <- can.cor.mtx$prec\n      can.log.det <- can.cor.mtx$log.det\n      \n      can.rss <- SumSquares(res, can.prec) / (sigma * ( 1 - delta^2))\n                      \n      rej <- -0.5 * sum(can.rss - cur.rss) + \n             0.5 * nt * (can.log.det - log.det) +\n             dnorm(can.norm.alpha, mean=alpha.m, sd=alpha.s, log=T) - \n             dnorm(norm.alpha, mean=alpha.m, sd=alpha.s, log=T)\n      \n      if (!is.na(rej)) { if (-rej < rexp(1, 1)) {\n        alpha     <- can.alpha\n        cor.mtx   <- can.cor.mtx\n        sig       <- can.sig\n        prec      <- can.prec\n        log.det   <- can.log.det\n        rss       <- can.rss\n        acc.alpha <- acc.alpha + 1\n      }}\n      \n    }  # fi !fixalpha\n    \n  }  # end nthin\n  \n  ##############################################\n  # Spatial Predictions\n  ##############################################\n  if (np > 0) {\n    partition.pred <- Membership(s=s.pred, knots=knots)\n    \n    for (t in 1:nt) {\n      x.beta.pred  <- x.pred[, t, ] %*% beta\n      z.sites.pred <- ZBySites(z=z.knots[, t], partition.pred)\n      mu.pred      <- x.beta.pred + delta * z.sites.pred\n      \n      s.11     <- 1\n      s.12     <- matrix(alpha * matern(d12, phi=rho, kappa=nu), nrow=np, ncol=ns)\n      s.22.inv <- prec\n      \n      e.y.pred <- mu.pred - s.12 %*% s.22.inv %*% (y[, t] - mu[, t])\n      v.y.pred <- sigma[t] * (1 - delta^2) * (s.11 - s.12 %*% s.22.inv %*% t(s.12))\n      \n      if (np > 1) {\n        v.y.pred <- diag(diag(v.y.pred))\n      }\n      \n      y.pred[, t, iter] <- rmvnorm(1, mean=e.y.pred, sigma=v.y.pred)\n      \n    }\n  }  # fi np > 0\n  \n  ##############################################\n  # Keep track of iterations\n  ##############################################\n  if (debug) { print(\"keepers\") }\n  keepers.z[iter, , ]   <- z.knots\n  keepers.beta[iter, ]  <- beta\n  keepers.sigma[iter, ] <- sigma\n  keepers.delta[iter]   <- delta\n  keepers.rho[iter]     <- rho\n  keepers.nu[iter]      <- nu\n  keepers.alpha[iter]   <- alpha\n  keepers.ll[iter, ]    <- cur.ll\n\n  ##############################################\n  # Display current value\n  ##############################################\n  if (debug) { print(\"plotting\") }\n  \n  if (iterplot) {\n    plotnow <- F\n    # different behavior if running on server vs testing\n    if (((iter %% update) == 0) & is.null(plotname)) {\n  \t  plotnow <- T\n  \t  plotmain <- \"\"\n  \t} else if ((iter == iters) & !is.null(plotname)) {\n  \t  plotnow <- T\n  \t  plotmain <- plotname\n      plotname.file <- paste(\"plots/\", plotname, sep=\"\")\n  \t  pdf(file=plotname.file)\n  \t}\n  \t\n  \tif (plotnow) {  \n  \t  accrate.w     <- round(acc.w / att.w, 3)\n  \t  accrate.delta <- round(acc.delta / att.delta, 3)\n  \t  accrate.rho   <- round(acc.rho / att.rho, 3)\n  \t  accrate.nu    <- round(acc.nu / att.nu, 3)\n  \t  accrate.alpha <- round(acc.alpha / att.alpha, 3)\n  \t  \t\n  \t  par(mfrow=c(3, 4))\n  \t  if (iter > burn) {\n  \t    start <- burn\n  \t  } else {\n  \t    start <- 1\n  \t  }\n  \t  plot(keepers.beta[start:iter, 1], ylab=\"beta0\", xlab=\"iteration\", \n           type=\"l\")\n      plot(keepers.beta[start:iter, 2], ylab=\"beta1\", xlab=\"iteration\",\n           type=\"l\", main=plotmain)\n      plot(keepers.beta[start:iter, 3], ylab=\"beta2\", xlab=\"iteration\",\n           type=\"l\")\n      plot(keepers.ll[start:iter], ylab=\"loglike\", xlab=\"iteration\",\n           type=\"l\")\n      plot(keepers.delta[start:iter], ylab=\"delta\", xlab=\"iteration\", \n           type=\"l\", main=bquote(\"ACCR\" == .(accrate.delta)))\n      plot(keepers.rho[start:iter], ylab=\"rho\", xlab=\"iteration\", \n            type=\"l\", main=bquote(\"ACCR\" == .(accrate.rho)))\n      plot(keepers.nu[start:iter], ylab=\"nu\", xlab=\"iteration\", \n           type=\"l\", main=bquote(\"ACCR\" == .(accrate.nu)))\n      plot(keepers.alpha[start:iter], ylab=\"alpha\", xlab=\"iteration\", \n           type=\"l\", main=bquote(\"ACCR\" == .(accrate.alpha)))\n      plot(keepers.sigma[start:iter, 1], ylab=\"sigma 1\", xlab=\"iteration\", \n           type=\"l\")\n      plot(keepers.sigma[start:iter, 3], ylab=\"sigma 3\", xlab=\"itertion\",\n           type=\"l\")\n      plot(keepers.z[start:iter, 1, 1], ylab=\"z 11\", xlab=\"iteration\", \n           type=\"l\")\n      plot(keepers.z[start:iter, 1, 3], ylab=\"z 31\", xlab=\"iteration\",\n           type=\"l\")\n  \t}\n  \t\n  \tif ((iter == iters) & !is.null(plotname)) {\n  \t  dev.off()\n  \t}\n  }  # fi iterplot\n  \n  ##############################################\n  # MH adapt candidate distributions\n  ##############################################\n  if (debug) { print(\"MH update\") }\n  if (iter < burn / 2) { \n    for (t in 1:nt) {\n      if (att.w[t] > 50) {\n        if (acc.w[t] / att.w[t] < 0.25) { mh.w[t] <- mh.w[t] * 0.8 }\n        if (acc.w[t] / att.w[t] > 0.50) { mh.w[t] <- mh.w[t] * 1.2 }\n        acc.w[t] <- att.w[t] <- 0.1\n      }\n    }\n    \n    if (att.delta > 50) {\n      if (acc.delta / att.delta < 0.25) { mh.delta <- mh.delta * 0.8 }\n      if (acc.delta / att.delta > 0.50) { mh.delta <- mh.delta * 1.2 }\n      acc.delta <- att.delta <- 0.1\n      # print(mh.delta)\n    }\n    if (att.rho > 50) {\n      if (acc.rho / att.rho < 0.25) { mh.rho <- mh.rho * 0.8 }\n      if (acc.rho / att.rho > 0.50) { mh.rho <- mh.rho * 1.2 }\n      acc.rho <- att.rho <- 0.1\n      # print(mh.rho)\n    }\n    if (att.nu > 50) {\n      if (acc.nu / att.nu < 0.25) { mh.nu <- mh.nu * 0.8 }\n      if (acc.nu / att.nu > 0.50) { mh.nu <- mh.nu * 1.2 }\n      acc.nu <- att.nu <- 0.1\n      # print(mh.nu)\n    }\n    if (att.alpha > 50) {\n      if (acc.alpha / att.alpha < 0.25) { mh.alpha <- mh.alpha * 0.8 }\n      if (acc.alpha / att.alpha > 0.50) { mh.alpha <- mh.alpha * 1.2 }\n      acc.alpha <- att.alpha <- 0.1\n      # print(mh.alpha)\n    }\n  }  # fi iter < burn / 2\n  \n  if ((iter %% update) == 0) {\n    cat(\"    Iter\", iter, \"complete. \\n\")\n  }\n  if (debug) { print(paste(\"iter: \", iter)) }\n\n  }  # end iter   \n  \n  ##############################################\n  # Return output\n  ##############################################\n  stop.time <- proc.time()\n  results   <- list(time=stop.time-start.time,\n                    z=keepers.z,\n                    beta=keepers.beta,\n                    sigma=keepers.sigma,\n                    delta=keepers.delta,\n                    rho=keepers.rho,\n                    nu=keepers.nu,\n                    alpha=keepers.alpha,\n                    yp=y.pred)\n  \n  return(results)\n}\n",
    "created" : 1399853303955.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "979676925",
    "id" : "990E5ECE",
    "lastKnownWriteTime" : 1399858106,
    "path" : "~/repos-git/extreme-value/pot/code/R/mcmc.R",
    "project_path" : "mcmc.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}