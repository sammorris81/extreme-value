{
    "contents" : "####################################################################\n# Auxiliary Functions\n####################################################################\n\n#########################################################################\n# Arguments:\n#   mn(nt): mean\n#   sd(nt, nt): standard deviation\n#   lower(1): lower truncation point (default=-Inf) \n#   upper(1): upper truncation point (default=Inf)\n#\tfudge(1): small number for numerical stability (used for lower bound)\n#\n# Returns:\n#   y(nt): truncated normal data\n#########################################################################\nrTNorm <- function(mn, sd, lower=-Inf, upper=Inf, fudge=0){\n  lower.u <- pnorm(lower, mn, sd)\n  upper.u <- pnorm(upper, mn, sd)\n\n  U <- runif(length(mn), lower.u, upper.u)\n  y <- qnorm(U, mn, sd)\n    \n  return(y)\n}\n\n#########################################################################\n# Arguments:\n#   nt(1): number of days\n#   s(ns, 2): spatial locations\n#   x(ns, nt, np): Matrix of spatial covariates\n#   beta.y(np): parameters for mu.y\n#   nu.y(1): smoothness parameter for Matern covariance\n#   alpha.y(1): controls proportion of spatial to non-spatial covariance\n#   thresh(1): percentage of data above threshold in GPD\n#   xi.r(1): a parameter for IG\n#   sig.r(1): b parameter for IG\n#\tmixprob(1): 0: all IG random effects; 1: all MVN random effects\n#\tmvn.rho(1): range parameter for MVN correlation\n#\tgam.rho(1): range parameter for IG correlation\n#   nknots(1): the number of knots/partitions to have over space\n#\n# Returns:\n#   list:\n#\t\ty(ns, nt): data\n#\t\tr.inv(nknots, nt): random effects for each knot and day\n#\t\tthresh.gen(1): sample quantile at which data is thresholded\n#\t\tknots(nknots, 2): knot locations\n#       fixr(nknots, nt): whether it was a gaussian or gamma random effect\n#########################################################################\nrpotspatial <- function(nt, s, x, beta, sigma, delta, rho, nu, alpha, nknots=1){\n    \n  # initial setup\n  ns      <- nrow(s)\n  y       <- matrix(NA, ns, nt)\n  z.knots <- matrix(NA, nrow=nknots, ncol=nt)\n  z.sites <- matrix(NA, nrow=ns, ncol=nt)\n  v       <- matrix(NA, nrow=ns, ncol=nt)\n  knots   <- vector(mode=\"list\", length=nt)\n  \n  d       <- rdist(s)\n  diag(d) <- 0\n  min1    <- min(s[, 1])\n  max1    <- max(s[, 1])\n  min2    <- min(s[, 2])\n  max2    <- max(s[, 2])\n  \n  for (t in 1:nt) {\n    # generate the knot locations\n    knots[[t]]      <- matrix(NA, nknots, 2)\n    knots[[t]][, 1] <- runif(nknots, min1, max1)\n    knots[[t]][, 2] <- runif(nknots, min2, max2)\n  }\n  \n  partition    <- Membership(s=s, knots=knots)\n   \n  for (t in 1:nt) {\n  \tsigma.t   <- sigma[t]\n  \tz.knots.t <- sqrt(sigma.t) * abs(rnorm(n=nknots, mean=0, sd=1))\n    z.sites.t <- ZBySites(z.knots.t, partition[, t])\n    \n    x.beta.t <- x[, t, ] %*% beta\n     \n    if (alpha != 0) {\n      cor    <- alpha * matern(u=d, phi=rho, kappa=nu)\n      v.spat <- t(chol(cor)) %*% rnorm(ns, 0, 1)\n    } else {\n      v.spat <- rep(0, ns)\n    }\n    \n    v.nug <- rnorm(ns, 0, sqrt(1 - alpha))\n    v.t <- sqrt(sigma.t) * sqrt(1 - delta^2) * ( v.nug + v.spat) \n    y[, t]       <- x.beta.t + delta * z.sites.t + v.t\n    z.knots[, t] <- z.knots.t\n    z.sites[, t] <- z.sites.t\n    v[, t]       <- v.t\n    \n  }\n  \n  results <- list(y=y, z.knots=z.knots, z.sites=z.sites, knots=knots, v=v, cor=cor)\n    \n  return(results)\n}\n\n################################################################\n# Arguments:\n#   s(ns, 2): spatial locations\n#   knots[nt](nknots, 2): list of knot locations matrices\n#\n# Returns: \n#   partition(ns, nt): partition membership matrix\n################################################################\nMembership <- function(s, knots){\n  ns <- nrow(s)\n  nt <- length(knots)\n  nknots <- nrow(knots[[1]])\n  partition <- matrix(NA, ns, nt) # a number letting us know which partition.\n  \n  # membership matrix\n  for (t in 1:nt) {\n    d <- rdist(s, knots[[t]])\n    partition[, t] <- apply(d, 1, which.min)\n  }\n  \n  return(partition)\n}\n\n################################################################\n# Arguments:\n#   s(ns, 2): spatial locations\n#\n# Returns:\n#   s.scale(ns, 2): locations scaled to be in [0, 1] x [0, 1]\n################################################################\nScaleLocs <- function(s){\n  x.min <- min(s[, 1]); x.max <- max(s[, 1]); x.range <- x.max - x.min\n  y.min <- min(s[, 2]); y.max <- max(s[, 2]); y.range <- y.max - y.min\n\n  s.x <- (s[,1] - x.min) / x.range\n  s.y <- (s[,2] - y.min) / y.range\n\t\n  s.scale <- cbind(s.x, s.y)\n\t\n  return(s.scale)   \n}\n\n\n\n################################################################\n# Arguments:\n#   d(ns, ns): distance between observations\n#   alpha(1): controls proportion of spatial to non-spatial \n#             covariance (0: ind, 1: high spatial corr)\n#   rho(1): spatial range\n#   nu(1): matern smoothness parameter\n#   eps(1): small amount for numerical stability\n#\n# Returns:\n#   list: \n#     prec(ns, ns): precision matrix\n#     log.det(nknots): logdet(prec)\n#     sig(ns, ns): correlation matrix\n################################################################\nSpatCor <- function(d, alpha, rho, nu=0.5, eps=10^(-5)){\n  q <- sig <- list()\n  \n  sig       <- CorFx(d, alpha, rho, nu, cov=FALSE)\n  sig.chol  <- chol(sig)\n  diag.chol <- ifelse(diag(sig.chol) < eps, eps, diag(sig.chol))\n  log.det   <- -2 * sum(log(diag.chol))\n  prec      <- chol2inv(sig.chol)\n  \n  results <- list(prec=prec, log.det=log.det, sig=sig)\n\n  return(results)\n\n}\n\n################################################################\n# Arguments:\n#   d(ns, ns): distance between observations\n#   alpha(1): controls proportion of spatial to non-spatial \n#             covariance (0: ind, 1: high spatial corr)\n#   rho(1): spatial range\n#   nu(1): matern smoothness parameter\n#\tcov(bool): do we need a variance term\n#\n# Returns:\n#   cor(ns, nt): matern correlation\n################################################################\nCorFx <- function(d, alpha, rho, nu, cov=F){\n    \n  ns <- nrow(d)\n  cor <- alpha * matern(d, rho, nu)\n  if (!cov) { # S12 doesn't need diagonal variance term\n    cor <- cor + (1 - alpha) * diag(rep(1, ns)) \n  } \n    \n  return(cor)\n}\n\n################################################################\n# Arguments:\n#   z(nknots): vector of random effects with one entry per knot\n#   partition(ns): partition membership vector\n#\n# Returns:\n#   z.sites(ns): vector of random effects with one entry per site\n################################################################\nZBySites <- function(z, partition){\n  nknots  <- length(z)\n  ns      <- length(partition)\n  z.sites <- rep(NA, ns)\n  \n  for (k in 1:nknots) {\n  \tthese <- which(partition == k)\n  \tz.sites[these] <- z[k]\n  }\n  \n  return(z.sites)\n}\n\n################################################################\n# Arguments:\n#   prec.beta(p, p): prior precision of beta\n#   e.beta(p): prior mean of beta\n#   x(ns, nt, p): covariate array\n#   y(ns, nt): observed data matrix\n#   z(ns, nt): matrix of random effects\n#   prec(ns, ns): precision matrix\n#   delta(1): skewness parameter\n#   sigma(nt): vector of daily variance\n#   nt(1): number of days\n#\n# Returns:\n#   list: \n#     vvv(p, p): posterior variance of beta\n#     mmm(p): posterior mean of beta\n################################################################\nBetaPosterior <- function(prec.beta, e.beta, x, y, z,\n\t\t\t\t\t\t  prec, delta, sigma, nt){\n  \n  ns  <- nrow(y)\n  p   <- length(e.beta)\n  vvv <- prec.beta\n  mmm <- e.beta\n  \n  for(t in 1:nt){\n      x.t <- matrix(x[, t, ], ns, p)\n      ttt  <- t(x.t) %*% prec / (sigma[t] * (1 - delta^2))\n      vvv  <- vvv + ttt %*% x.t\n      mmm  <- mmm + ttt %*% (y[, t] + delta * z[, t])\n  }\n\t\n  vvv <- chol2inv(chol(vvv))\n\n  results <- list(vvv=vvv, mmm=mmm)\n\n  return(results)\n}\n\n################################################################\n# Arguments:\n#   res(ns, nt)\n#   prec(ns, ns): precision matrix\n#\n# Returns:\n#   ss(nt): vector of daily sums of squares\n################################################################\nSumSquares <- function(res, prec){\n  nt <- ncol(res)\n  ss <- rep(NA, nt)\n  \n  for (t in 1:nt) {\n    ss[t] <- t(res[, t]) %*% prec %*% res[, t]\n  }\n  \n  return(ss)\n}\n\n################################################################\n# Arguments:\n#   y(ns, nt): observed data matrix\n#   x.beta(ns, nt): XBeta matrix\n#   sigma(nt): vector of daily variance\n#   delta(1): skewness parameter\n#   prec(ns, ns): precision matrix\n#   log.det(1): logdet(prec)\n#   z.sites(ns, nt): matrix of random effects\n#\n# Returns:\n#   llike(nt): (log)likelihood\n################################################################\nLLike <- function(y, x.beta, sigma, delta, prec, log.det, z.sites, log=TRUE){\n  \n  if (missing(y)) {\n    stop(\"y must be defined\")\n  } \n  ns <- nrow(y)\n  nt <- ncol(y)\n  if (missing(x.beta)) {\n    stop(\"x.beta must be defined\")\n  } else if (nrow(x.beta) != ns || ncol(x.beta) != nt) {\n    stop(\"x.beta and y must have conforming size\")\n  }\n  \n  if (missing(sigma)) {\n    stop(\"sigma must be defined\")\n  } else if (length(sigma) != nt) {\n    stop(\"need a sigma for each day\")\n  }\n  \n  if (missing(delta)) {\n    stop(\"delta must be defined\")\n  }\n  \n  if (missing(log.det)) {\n    stop(\"log.det must be defined\")\n  }\n      \n  log.like  <- rep(NA, nt)\n\n  for (t in 1:nt) {\n    sigma.t <- sigma[t]\n    y.t <- y[, t]\n    mu.t <- x.beta[, t] + delta * z.sites[, t]\n    ss.t <- t(y.t - mu.t) %*% prec %*% (y.t - mu.t)\n    log.like[t] <- -0.5 * ns * (log(sigma.t) + log(1 - delta^2)) + 0.5 * log.det -\n                    0.5 * ss.t / (sigma.t * (1 - delta^2))\n  }\n    \n  if(!log){\n    log.like <- exp(log.like)\n  }\n    \n  return(log.like)\n}\n\n################################################################\n# IG(a, b) density function\n################################################################\ndInvG <- function(x, a, b, log=T){\n  lll <- -(a + 1) * log(x) - b / x\n  if (!log) {\n    lll<-exp(lll)\n  }\n    \n  return(lll)\n}\n",
    "created" : 1399853740473.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2728002368",
    "id" : "1DE6AE2D",
    "lastKnownWriteTime" : 1399853751,
    "path" : "~/repos-git/extreme-value/pot/code/R/auxfunctions.R",
    "project_path" : "auxfunctions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}